<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Bloxd Sound Converter</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="image" content="https://bloxd.io/img/bloxd-icon-512.png" />
<style>
  body { font-family: system-ui, sans-serif; padding: 20px; max-width: 900px; margin: auto; }
  label { display:block; margin-top:12px; font-weight:600; }
  input[type="text"], input[type="number"] { width:100%; padding:8px; box-sizing:border-box; }
  button { margin-top:12px; padding:10px 14px; }
  pre { background:#f6f6f6; padding:12px; overflow:auto; }
  .row { display:flex; gap:12px; align-items:center; margin-top:8px; }
  .small { font-size:0.9em; color:#555; }
</style>
</head>
<body>

<h2>Bloxd Sound Converter</h2>

<div id="loadStatus">Loading palette and sound names…</div>

<label>Target Sound (audio file)</label>
<input id="targetFile" type="file" accept="audio/*">

<label>Maximum Number of Sounds in Mix</label>
<input id="maxSounds" type="number" min="1" value="3">

<h3>Frequency Weighting</h3>

<label>Low Frequencies</label>
<input id="lowWeight" type="range" min="0" max="5" step="0.1" value="1">

<label>Mid Frequencies</label>
<input id="midWeight" type="range" min="0" max="5" step="0.1" value="1">

<label>High Frequencies</label>
<input id="highWeight" type="range" min="0" max="5" step="0.1" value="1">

<h3>Advanced Settings</h3>

<label>Duration Weight</label>
<input id="durationWeight" type="range" min="0" max="5" step="0.1" value="1">

<label>Optimization Iterations</label>
<input id="iterationSlider" type="range" min="100" max="5000" step="100" value="700">

<div class="row">
  <button id="runBtn" disabled>Start Optimization</button>
  <button id="playResultBtn" disabled>Play Result</button>
  <div class="small" id="status">Waiting for target sound…</div>
</div>

<h3>Result (JSON)</h3>
<pre id="output">[]</pre>

<script>
/* ------------------------------------------------------------
   GLOBALS
------------------------------------------------------------ */
let audioCtx = null;
let paletteBuffers = {};
let paletteNames = [];
let targetBuffer = null;
let resultConfig = null;
let featureMap = {};

function getAudioContext() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

/* ------------------------------------------------------------
   FILE LOADING HELPERS
------------------------------------------------------------ */
async function loadText(url) {
  const res = await fetch(url);
  return await res.text();
}

async function loadAudio(url) {
  const ctx = getAudioContext();
  const res = await fetch(url);
  const ab = await res.arrayBuffer();
  return await ctx.decodeAudioData(ab);
}

/* ------------------------------------------------------------
   RMS
------------------------------------------------------------ */
function computeRMS(buffer) {
  const ch = buffer.getChannelData(0);
  let sum = 0;
  for (let i = 0; i < ch.length; i++) sum += ch[i] * ch[i];
  return Math.sqrt(sum / ch.length);
}

/* ------------------------------------------------------------
   FFT (Hann + 2048)
------------------------------------------------------------ */
function hannWindow(N) {
  const w = new Float32Array(N);
  for (let i = 0; i < N; i++) w[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (N - 1)));
  return w;
}

function fftReal(input) {
  const N = input.length;
  const real = input.slice();
  const imag = new Float32Array(N);

  for (let i = 1, j = 0; i < N; i++) {
    let bit = N >> 1;
    for (; j & bit; bit >>= 1) j ^= bit;
    j ^= bit;
    if (i < j) {
      [real[i], real[j]] = [real[j], real[i]];
      [imag[i], imag[j]] = [imag[j], imag[i]];
    }
  }

  for (let len = 2; len <= N; len <<= 1) {
    const ang = -2 * Math.PI / len;
    const wlen_r = Math.cos(ang);
    const wlen_i = Math.sin(ang);

    for (let i = 0; i < N; i += len) {
      let wr = 1, wi = 0;
      for (let j = 0; j < len / 2; j++) {
        const u_r = real[i + j];
        const u_i = imag[i + j];
        const v_r = real[i + j + len/2] * wr - imag[i + j + len/2] * wi;
        const v_i = real[i + j + len/2] * wi + imag[i + j + len/2] * wr;

        real[i + j] = u_r + v_r;
        imag[i + j] = u_i + v_i;
        real[i + j + len/2] = u_r - v_r;
        imag[i + j + len/2] = u_i - v_i;

        const next_wr = wr * wlen_r - wi * wlen_i;
        wi = wr * wlen_i + wi * wlen_r;
        wr = next_wr;
      }
    }
  }

  return { real, imag };
}

function analyzeSpectrum(buffer) {
  const N = 2048;
  const data = buffer.getChannelData(0);
  if (data.length < N) return { low:0, mid:0, high:0 };

  const slice = data.subarray(0, N);
  const window = hannWindow(N);
  const windowed = new Float32Array(N);
  for (let i = 0; i < N; i++) windowed[i] = slice[i] * window[i];

  const { real, imag } = fftReal(windowed);

  const mags = new Float32Array(N/2);
  for (let i = 0; i < N/2; i++) {
    mags[i] = Math.sqrt(real[i]*real[i] + imag[i]*imag[i]);
  }

  const sr = buffer.sampleRate;
  const hzPerBin = sr / N;

  let low = 0, mid = 0, high = 0;

  for (let i = 0; i < mags.length; i++) {
    const hz = i * hzPerBin;
    if (hz < 200) low += mags[i];
    else if (hz < 2000) mid += mags[i];
    else high += mags[i];
  }

  const total = low + mid + high || 1;
  return {
    low: low / total,
    mid: mid / total,
    high: high / total
  };
}

/* ------------------------------------------------------------
   SPLIT PALETTE BY SILENCE
------------------------------------------------------------ */
function splitBySilence(buffer, silenceThreshold = 0.005, minSegmentSamples = 2048) {
  const data = buffer.getChannelData(0);
  const sr = buffer.sampleRate;
  const segments = [];
  let start = null;
  let silentCount = 0;
  const minSilentSamples = Math.floor(0.02 * sr);

  for (let i = 0; i < data.length; i++) {
    const abs = Math.abs(data[i]);
    if (abs > silenceThreshold) {
      if (start === null) start = i;
      silentCount = 0;
    } else {
      if (start !== null) {
        silentCount++;
        if (silentCount > minSilentSamples) {
          const end = i - silentCount;
          if (end - start > minSegmentSamples) segments.push([start, end]);
          start = null;
          silentCount = 0;
        }
      }
    }
  }
  if (start !== null && data.length - start > minSegmentSamples) {
    segments.push([start, data.length - 1]);
  }

  const ctx = getAudioContext();
  return segments.map(([s, e]) => {
    const len = e - s + 1;
    const newBuf = ctx.createBuffer(1, len, buffer.sampleRate);
    newBuf.copyToChannel(data.subarray(s, e + 1), 0);
    return newBuf;
  });
}

/* ------------------------------------------------------------
   MIX SIMULATION + SCORE
------------------------------------------------------------ */
function simulateMix(config, featureMap) {
  let low = 0, mid = 0, high = 0, loud = 0;
  let duration = 0;

  for (const e of config) {
    const f = featureMap[e.soundName];
    low  += f.low  * e.volume;
    mid  += f.mid  * e.volume;
    high += f.high * e.volume;
    loud += f.loudness * e.volume;

    const d = f.duration / e.pitch;
    if (d > duration) duration = d;
  }

  return { low, mid, high, loudness: loud, duration };
}

function score(target, mix, weights) {
  return (
    Math.abs(target.low  - mix.low ) * weights.low  +
    Math.abs(target.mid  - mix.mid ) * weights.mid  +
    Math.abs(target.high - mix.high) * weights.high +
    Math.abs(target.loudness - mix.loudness) +
    Math.abs(target.duration - mix.duration) * weights.duration
  );
}

/* ------------------------------------------------------------
   EVOLUTIONARY OPTIMIZER
------------------------------------------------------------ */
function randomConfig(names, maxSounds) {
  const shuffled = names.slice().sort(() => Math.random() - 0.5);
  const chosen = shuffled.slice(0, maxSounds);
  return chosen.map(n => ({
    soundName: n,
    pitch: +(0.6 + Math.random() * 1.6).toFixed(3),
    volume: +Math.random().toFixed(3)
  }));
}

function mutateConfig(cfg, names, maxSounds) {
  const out = cfg.map(e => ({ ...e }));

  if (Math.random() < 0.15) {
    const idx = Math.floor(Math.random() * out.length);
    out[idx].soundName = names[Math.floor(Math.random() * names.length)];
  }

  for (let i = 0; i < out.length; i++) {
    if (Math.random() < 0.7)
      out[i].pitch = Math.max(0.2, Math.min(3, +(out[i].pitch * (0.9 + Math.random() * 0.2)).toFixed(3)));
    if (Math.random() < 0.8)
      out[i].volume = Math.max(0, Math.min(1, +(out[i].volume * (0.85 + Math.random() * 0.3)).toFixed(3)));
  }

  if (Math.random() < 0.05 && out.length < maxSounds) {
    const add = names[Math.floor(Math.random() * names.length)];
    out.push({ soundName: add, pitch: +(0.8 + Math.random() * 1.4).toFixed(3), volume: +Math.random().toFixed(3) });
  }

  if (Math.random() < 0.05 && out.length > 1) {
    out.splice(Math.floor(Math.random() * out.length), 1);
  }

  return out.slice(0, maxSounds);
}

function optimize(names, featureMap, target, maxSounds, iterations, population, weights) {
  let pop = [];
  for (let i = 0; i < population; i++) pop.push(randomConfig(names, maxSounds));

  let best = pop[0];
  let bestScore = Infinity;

  for (let gen = 0; gen < iterations; gen++) {
    const scored = pop.map(cfg => {
      const mix = simulateMix(cfg, featureMap);
      return { cfg, s: score(target, mix, weights) };
    }).sort((a,b) => a.s - b.s);

    if (scored[0].s < bestScore) {
      bestScore = scored[0].s;
      best = scored[0].cfg;
    }

    const survivors = scored.slice(0, Math.max(2, Math.floor(population/3))).map(x => x.cfg);
    const newPop = survivors.slice();
    while (newPop.length < population) {
      const parent = survivors[Math.floor(Math.random() * survivors.length)];
      newPop.push(mutateConfig(parent, names, maxSounds));
    }
    pop = newPop;
  }

  return best;
}

/* ------------------------------------------------------------
   PLAYBACK
------------------------------------------------------------ */
function playConfig(config, buffers) {
  const ctx = getAudioContext();
  const now = ctx.currentTime + 0.05;

  for (const entry of config) {
    const buf = buffers[entry.soundName];
    if (!buf) continue;

    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.playbackRate.value = entry.pitch;

    const g = ctx.createGain();
    g.gain.value = entry.volume;

    src.connect(g).connect(ctx.destination);
    src.start(now);
    src.stop(now + buf.duration / Math.max(0.01, entry.pitch));
  }
}

/* ------------------------------------------------------------
   INITIAL LOAD OF PALETTE + NAMES
------------------------------------------------------------ */
(async function init() {
  const loadStatus = document.getElementById("loadStatus");
  loadStatus.textContent = "Loading sound names…";

  const namesText = await loadText("sounds.txt");
  paletteNames = namesText.trim().split(/\s+/);

  loadStatus.textContent = "Loading palette audio…";
  const paletteBuf = await loadAudio("palette.mp3");

  loadStatus.textContent = "Splitting palette…";
  const segments = splitBySilence(paletteBuf);

  if (segments.length < paletteNames.length) {
    loadStatus.textContent = "Error: palette has fewer segments than names.";
    return;
  }

  paletteBuffers = {};
  for (let i = 0; i < paletteNames.length; i++) {
    paletteBuffers[paletteNames[i]] = segments[i];
  }

  loadStatus.textContent = "Extracting FFT features…";
  featureMap = {};
  for (const n of paletteNames) {
    const b = paletteBuffers[n];
    const spec = analyzeSpectrum(b);
    featureMap[n] = {
      low: spec.low,
      mid: spec.mid,
      high: spec.high,
      loudness: computeRMS(b),
      duration: b.duration
    };
  }

  loadStatus.textContent = "Palette ready.";
  document.getElementById("runBtn").disabled = false;
})();

/* ------------------------------------------------------------
   OPTIMIZATION BUTTON
------------------------------------------------------------ */
document.getElementById("runBtn").onclick = async () => {
  const targetFile = document.getElementById("targetFile").files[0];
  const maxSounds = parseInt(document.getElementById("maxSounds").value);

  const weights = {
    low: parseFloat(document.getElementById("lowWeight").value),
    mid: parseFloat(document.getElementById("midWeight").value),
    high: parseFloat(document.getElementById("highWeight").value),
    duration: parseFloat(document.getElementById("durationWeight").value)
  };

  const iterations = parseInt(document.getElementById("iterationSlider").value);

  const status = document.getElementById("status");
  const output = document.getElementById("output");
  const playBtn = document.getElementById("playResultBtn");

  if (!targetFile) {
    alert("Please select a target sound.");
    return;
  }

  status.textContent = "Loading target sound…";
  targetBuffer = await loadAudio(URL.createObjectURL(targetFile));

  status.textContent = "Analyzing target FFT…";
  const targetSpec = analyzeSpectrum(targetBuffer);
  const targetFeatures = {
    low: targetSpec.low,
    mid: targetSpec.mid,
    high: targetSpec.high,
    loudness: computeRMS(targetBuffer),
    duration: targetBuffer.duration
  };

  status.textContent = "Running optimization…";
  const best = optimize(paletteNames, featureMap, targetFeatures, maxSounds, iterations, 14, weights);

  let volSum = best.reduce((s,e) => s + e.volume, 0);
  if (volSum > 1) {
    for (const e of best) e.volume = +(e.volume / volSum).toFixed(3);
  }

  resultConfig = best;
  output.textContent = JSON.stringify(best, null, 2);
  status.textContent = "Done.";
  playBtn.disabled = false;
};

/* ------------------------------------------------------------
   PLAY RESULT
------------------------------------------------------------ */
document.getElementById("playResultBtn").onclick = () => {
  if (!resultConfig) return;
  getAudioContext().resume();
  playConfig(resultConfig, paletteBuffers);
};
</script>

</body>
</html>
